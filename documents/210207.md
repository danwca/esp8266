2021年2月7日开始，功能码工作机制，主要内容：
1. 修改功能码工作机制，参见，[功能码工作机制](function.md)
1. fn_init，在wos.c中初始化；wos.c需要加载（inlcude.h）所有功能码；
1. eprom_init，在wos.c中定义，读取eprom，调用功能码的init函数
1. 确定function.c，fn_list，regfunction，runfunction；主要完成功能码注册和功能码运行功能；
1. 编译通过，没有编译错误，(210211130156.png)
1. 调试_eprom_init函数(wos.c)，从eprom到fn_data和fn_list的转换；debug_eprom_init；issue Fatal exception 0; issue Fatal exception 29; issue memory alloc size
1. 调试runfunction(function.c)，修改功能码的init函数，通过regfunction注册功能码；issue function runtime; issue Fatal exception 28
1. 增加调试功能，debug.h；通过宏的方式，定义调试模式；调试模式下，生成os_printf的调试语句；在非调试模式下，采用空字符串删除调试代码；
1. 仿真设备的调试，安装C19；
1. 读写EPROM；编写专门的EPROM写入程序，通过主控板，将数据写入EPROM中；

## 
建立eprom.c, eprom.h；主要用于与eprom中数据的接口，函数read_config：入口参数addr：地址；按int方式读取组态数据；目前，组态数据保存在变量_EPROM中；等建立eprom组态数据机制，组态数据保存在eprom中，则修改函数read_config，通过I2C机制，从EPROM中读取数据；系统需要提供功能码清单；根据组态数据建立动态内存；

动态内存代码：
```
#include <malloc.h>
//malloc (s)
//free (p), for block mechanism, free not used
void *malloc(size_t size);
```

```
user/wos.c:48:21: error: incompatible implicit declaration of built-in function 'malloc' [-Werror]
```
改用os_malloc替代malloc；问题解决；


## EPROM的I2C操作代码
```
//Random Read
I2C_Start();
I2C_SendByte(DEVICE ADDRESS+WRITE, 1); //发送写器件地址=0xA0
I2C_SendByte(WORD ADDRESS, 1); //发送要读取的地址
I2C_Start();
I2C_SendByte(DEVICE ADDRESS+READ, 1); //发送读器件地址=0xA1
num=I2C_ReadByte(); //读取数据
I2C_Stop()
```
```
//Byte Write
I2C_Start();
I2C_SendByte(DEVICE ADDRESS, 1);//发送写器件地址=0xA0
I2C_SendByte(WORD ADDRESS, 1);//发送要写入内存地址,
I2C_SendByte(DATA, 0); //发送数据,
I2C_Stop();
```

## Struct and union initialization
```
union { int x; char c[4]; }
u = {1},           // makes u.x active with value 1
u2 = { .c={'\1'} }; // makes u2.c active with value {'\1','\0','\0','\0'}
```

```
struct point {double x,y,z;} p = {1.2, 1.3}; // p.x=1.2, p.y=1.3, p.z=0.0
div_t answer = {.quot = 2, .rem = -1 };      // order of elements in div_t may vary
```

```
struct {int sec,min,hour,day,mon,year;} z
   = {.day=31,12,2014,.sec=30,15,17}; // initializes z to {30,15,17,31,12,2014}
```

```
struct example {
    struct addr_t {
       uint32_t port;
    } addr;
    union {
       uint8_t a8[4];
       uint16_t a16[2];
    } in_u;
};
struct example ex = { // start of initializer list for struct example
                     { // start of initializer list for ex.addr
                        80 // initialized struct's only member
                     }, // end of initializer list for ex.addr
                     { // start of initializer-list for ex.in_u
                        {127,0,0,1} // initializes first element of the union
                     } };
struct example ex = {80, 127, 0, 0, 1}; // 80 initializes ex.addr.port
                                        // 127 initializes ex.in_u.a8[0]
                                        // 0 initializes ex.in_u.a8[1]
                                        // 0 initializes ex.in_u.a8[2]
                                        // 1 initializes ex.in_u.a8[3]

struct example ex2 = { // current object is ex2, designators are for members of example
                       .in_u.a8[0]=127, 0, 0, 1, .addr=80}; 
struct example ex3 = {80, .in_u={ // changes current object to the union ex.in_u
                           127,
                           .a8[2]=1 // this designator refers to the member of in_u
                      } };
```
```
struct {int n;} s = {printf("a\n"), // this may be printed or skipped
                     .n=printf("b\n")}; // always printed
```
```
#include <stdio.h>
typedef struct { int k; int l; int a[2]; } T;
typedef struct { int i;  T t; } S;
T x = {.l = 43, .k = 42, .a[1] = 19, .a[0] = 18 };
 // x initialized to {42, 43, {18, 19} }
int main(void)
{
    S l = { 1,          // initializes l.i to 1
           .t = x,      // initializes l.t to {42, 43, {18, 19} }
           .t.l = 41,   // changes l.t to {42, 41, {18, 19} }
           .t.a[1] = 17 // changes l.t to {42, 41, {18, 17} }
          };
    printf("l.t.k is %d\n", l.t.k); // .t = x sets l.t.k to 42 explicitly
                                    // .t.l = 41 would zero out l.t.k implicitly
}
```

```
struct fred { char s[4]; int n; };
struct fred x[ ] = { { { "abc" }, 1 }, // inits x[0] to { {'a','b','c','\0'}, 1 }
                      [0].s[0] = 'q'   // changes x[0] to { {'q','b','c','\0'}, 1 }
                   };
struct fred y[ ] = { { { "abc" }, 1 }, // inits y[0] to { {'a','b','c','\0'}, 1 }
                     [0] = { // current object is now the entire y[0] object
                             .s[0] = 'q' 
                            } // replaces y[0] with { {'q','\0','\0','\0'}, 0 }
                    };
```

## typedef
此关键字的使用，主要是为了简化由struct，union和enum声明的变量的语句的书写：
```
//struct声明变量的方式
struct STR str;	// STR is a struct，keyword struct can not omited.
typedef struct STR S;
S str; // S is a type, defined by typedef; no keyword struct required.
// union和enum与struct情况类似
```
```
typedef struct X {}; // ill-formed
```

```
// simple typedef
typedef unsigned long ulong;
 
// the following two objects have the same type
unsigned long l1;
ulong l2;
 
// more complicated typedef
typedef int int_t, *intp_t, (&fp)(int, ulong), arr_t[10];
 
// the following two objects have the same type
int a1[10];
arr_t a2;
 
// common C idiom to avoid having to write "struct S"
typedef struct {int a; int b;} S, *pS;
 
// the following two objects have the same type
pS ps1;
S* ps2;
 
// error: storage-class-specifier cannot appear in a typedef declaration
// typedef static unsigned int uint;
 
// typedef can be used anywhere in the decl-specifier-seq
long unsigned typedef int long ullong;
// more conventionally spelled "typedef unsigned long long int ullong;"
 
// std::add_const, like many other metafunctions, use member typedefs
template< class T>
struct add_const {
    typedef const T type;
};
 
typedef struct Node {
    struct listNode* next; // declares a new (incomplete) struct type named listNode
} listNode; // error: conflicts with the previously declared struct name
```

## getblock & setblock
(block.c & block.h)
此二函数在功能块与数据变量之间完成数据的交换；功能块中包含数据指针和数据转换函数指针；功能块的数据类型没有进行管理，由程序代码自行控制；
```
void getblock(int, void*);
void setblock(int, void*);
```
是否需要转换函数，需要重新考虑；如果仅仅是数据传递，即在相同的数据类型变量之间传递数据，则不需要进行数据转换；通过定义编译宏来控制此问题，_BLOCK_TRANS & _BLOCK_SIMPLE，默认情况使用_BLOCK_SIMPLE；

## C Preprocessor directives
https://docs.microsoft.com/en-us/cpp/preprocessor/preprocessor-directives?view=msvc-160
https://docs.microsoft.com/en-us/cpp/preprocessor/hash-if-hash-elif-hash-else-and-hash-endif-directives-c-cpp?view=msvc-160
https://docs.microsoft.com/en-us/cpp/preprocessor/hash-ifdef-and-hash-ifndef-directives-c-cpp?view=msvc-160
https://docs.microsoft.com/en-us/cpp/preprocessor/grammar-summary-c-cpp?view=msvc-160
```
#if defined(CREDIT)
    credit();
#elif defined(DEBIT)
    debit();
#else
    printerror();
#endif
```
```
#if !defined( EXAMPLE_H )
#define EXAMPLE_H
//...
#endif // !defined( EXAMPLE_H )
```

## github markdown
https://styleguide.github.com/primer/utilities/colors/

## issue Fatal exception 0:
see detail (Fatal exception 0/readme.md)
## issue Fatal exception 29:
see detail (Fatal exception 29/readme.md)
## issue memory alloc size
根据组态数据动态分配空间，用于功能码的运行空间
##issue function runtime
功能码的运行时间控制，是定时器，还是自由循环？是整个功能码清单循环（fullloop），还是单个功能码循环（singleloop）？
定义宏，function_singleloop & function_fullloop; 默认为全循环（function_fullloop）；

## issue Fatal exception 28
see detail (Fatal exception 28/readme.md)

